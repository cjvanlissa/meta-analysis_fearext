---
title: "Meta-Analysis Fear Extinction"
author: "Caspar J. Van Lissa, for Caroline Kwee, Nadia Leen, Lucianne Groenink & Joke Baas"
output: bookdown::html_document2
date: '`r format(Sys.time(), "%d %B, %Y")`'
bibliography: references.bib
knit: worcs::cite_all
---

```{r setup, include=FALSE}
run_everything = FALSE
library("worcs")
library(ggplot2)
library(kableExtra)
library(DT)
library(tidySEM)
library(knitr)
knitr::opts_chunk$set(echo = FALSE)
```


```{r prepdata, eval=run_everything}
library(metafor)
library(pema)

# We recommend that you prepare your raw data for analysis in 'prepare_data.R',
# and end that file with either open_data(yourdata), or closed_data(yourdata).
# Then, uncomment the line below to load the original or synthetic data
# (whichever is available), to allow anyone to reproduce your code:
load_data()
dat$paper <- as.character(dat$paper)
dat$author <- as.character(dat$author)
dat$dose_unit <- as.character(dat$dose_unit)
dat$strain <- as.character(dat$strain)
dat$id_sample <- as.integer(factor(do.call("paste", dat[c("paper", "id_sample")])))
cat <- sapply(dat, inherits, "factor")

# for(v in names(dat)[cat]){
#   out <- data.frame(Variable = v, Levs = levels(dat[[v]]))
#   write.table(out, "rename_cats.csv", append = TRUE, row.names = F, col.names = F, sep = ",")
# }
recat <- read.csv("rename_cats.csv", stringsAsFactors = F, header = F)
for(v in names(dat)[cat]){
  thelevs <- recat[recat[[1]] == v, ]
  levels(dat[[v]]) <- thelevs$V3[match(levels(dat[[v]]), thelevs$V2)]
}

dat$Sample <- ordered(dat$Sample, levels = c("CBDhumanexperimental", "CBDanimalconditioned", 
"CBDanimalunconditioned", "AM404conditioned", "AM404unconditioned", "URB597conditioned", "URB597unconditioned", "PF3485unconditioned")
)
samples <- levels(dat$Sample)

dat <- escalc(measure = "SMD",
         n1i = dat$ncon,
         n2i = dat$ntreat,
         m1i = dat$mcon,
         m2i = dat$mtreat,
         sd1i = dat$sdcon,
         sd2i = dat$sdtreat,
         data = dat)

dat <- dat[!is.na(dat$yi), ]
zscores <- scale(dat[["yi"]])
maxz <- max(abs(zscores))
#dat <- dat[-which.max(zscores), ]
mods_cont <- c("dose", "hed")
dat[mods_cont] <- lapply(dat[mods_cont], function(x)as.vector(scale(x, scale = FALSE)))
dat[paste0(mods_cont, "2")] <- lapply(dat[mods_cont], function(x)x^2)
saveRDS(dat, "dat.RData")
```

```{r}
dat <- readRDS("dat.RData")
samples <- levels(dat$Sample)
mods <- c("year", "dose",  "dose2", "hed", "hed2", "sex", "administration", "timing", "disease", "anxiety_test","species", "outcome_type", "frequency")
```


<!--   Information regarding this data file for the SR fear learning & SSRIs -->

<!-- This data file is organised by fear learning Sample. This means that every fear learning Sample has its own Excel sheet. -->

<!-- Within these sheets you find the same layout. The different columns are explained below: -->

<!--   Study name -->
<!-- Article code -->
<!-- Type of SSRI -->
<!-- Frequency -->
<!-- Disease induction -->
<!-- Species -->
<!-- Type of test -->
<!-- Sensitivity analysis -->



<!-- Analyses we want to perform: -->
<!-- 2. Subgroup analyses of the five factors (SSRI, frequency, disease induction, species, type of test) per fear learning Sample -->
<!-- 3. Check for multi collinearity -->

```{r threelev, echo=FALSE, warning=FALSE, message=FALSE, results="hide", eval = run_everything}
mlm <- lapply(samples, function(p){
  df <- dat[dat$Sample == p, ]
  #Conduct meta-analyses
  #model.mods <- rma.mv(yi, vi, random = list(~ 1 | id_sample, ~ 1 | id_es), data=df) 
  model.full <- rma.mv(yi, vi, random = list(~ 1 | id_sample, ~ 1 | id_es), data=df) 
  model.within_null <- rma.mv(yi, vi, random = list(~ 1 | id_sample, ~ 1 | id_es), sigma2=c(NA,0), data = df) 
  model.between_null <- rma.mv(yi, vi, random = list(~ 1 | id_sample, ~ 1 | id_es), sigma2=c(0,NA), data = df) 
model.both_null <- rma.mv(yi, vi, random = list(~ 1 | id_sample, ~ 1 | id_es), sigma2=c(0,0), data = df) 
#model.mods <- rma.mv(yi, vi, mods = as.formula(paste0("~ ", paste(moderators, collapse = " + "))), random = list(~ 1 | id_sample, ~ 1 | id_es), data = df) 
#ggplot(, aes(x=d, colour=interventioncode))+geom_density()
#anova(model.full,rma.mv(yi, vi, mods = ~interventioncode, random = list(~ 1 | id_sample, ~ 1 | id_es), data = df) ) 
aov_within <- anova(model.full,model.within_null) 
aov_between <- anova(model.full,model.between_null) 
aov_bothnull <- anova(model.full,model.both_null) 
aov_table <- data.frame(rbind(
c(aov_between$fit.stats.f[c(3:4, 1)], LRT = NA, p = NA),
c(aov_within$fit.stats.r[c(3:4, 1)], LRT = aov_within$LRT, p = aov_within$pval),
c(aov_between$fit.stats.r[c(3:4, 1)], LRT = aov_between$LRT, p = aov_between$pval),
c(aov_bothnull$fit.stats.r[c(3:4, 1)], LRT = aov_bothnull$LRT, p = aov_bothnull$pval)
))
rownames(aov_table) <- c("Three-level model", "Within-studies variance constrained", "Between-studies variance constrained", "Both variance components constrained")
write.csv(aov_table, paste0("threelevel_ma_", p, ".csv"))
confints <- confint(model.full)
#CHeck convergence of variance components:
#par(mfrow=c(2,1))
#plot.profile1 <- profile(model.full, sigma2=1)
#plot.profile2 <- profile(model.full, sigma2=2)

#Write forest plot to file
xname <- paste0("Hedges' g (", p, ")")
tmp <- df[order(df$vi, decreasing = TRUE), ]
df_es <- data.frame(
    Study = ordered(tmp$paper, levels = unique(tmp$paper)),
    y = 1:nrow(tmp),
    es = tmp$yi,
    lb = tmp$yi - 1.96*sqrt(tmp$vi),
    ub = tmp$yi + 1.96*sqrt(tmp$vi),
    Sample = p)

dfoverall <- data.frame(x = c(model.full$ci.ub, model.full$b[1,1], model.full$ci.lb, model.full$b[1,1]),
                        y = c(max(df_es$y)+2, max(df_es$y)+2.5, max(df_es$y)+2, max(df_es$y)+1.5))
ylabsize = 10
if(p == "Acq retr to ctx") ylabsize =1
pforest <- ggplot(data=df_es)+ 
  geom_point(aes(y=y, x=es))+ 
  geom_errorbarh(aes(y = y, xmin=lb, xmax=ub), height=.1)+
  
  # geom_point(data=data.frame(y = max(df_es$y)+2, es = model.full$b[1,1]), aes(y=y, x=es), size=4, shape = 15, fill = "black")+ 
  # geom_errorbarh(data = data.frame(y = max(df_es$y)+2, lb = model.full$ci.lb, ub = model.full$ci.ub), aes(y = y, xmin=lb, xmax=ub), height=.4, size = 2)+
  geom_polygon(data = dfoverall, aes(x = x, y = y))+
  scale_x_continuous(name=xname, limits = c(min(df_es$lb), min(c(10,max(df_es$ub)))))+
  scale_y_continuous(name = "", breaks=1:max(df_es$y), labels = df_es$Study, trans="reverse")+
  #adding a vertical line at the effect = 0 mark
  geom_vline(xintercept=0, color="black", linetype="dashed", alpha=.5)+
  geom_hline(yintercept=max(df_es$y)+1)+
  theme(axis.text.y = element_text(size=ylabsize))+
  theme_minimal()

ggsave(paste0("threelevel_ma_forest", p, ".png"), pforest, device = "png", height = (nrow(df)+2)*.2)
res = data.frame(Variance = c("Overall ES", "V within", "V between"),
                 rbind(c(estimate = model.full$b[1,1], ci.lb = model.full$ci.lb, ci.ub = model.full$ci.ub, model.full$pval),
                       c(confints[[1]]$random[1,], aov_table$p[3]),
                       c(confints[[2]]$random[1,], aov_table$p[2])))
  list(mod = model.full,
    aov_table = aov_table,
       res = res)     
})
names(mlm) <- samples
saveRDS(mlm, "mlm.RData")

tb <- lapply(1:length(samples), function(i){
  tb <- mlm[[i]]$res
  tb$Sample <- samples[i]
  tb
})
tb <- do.call(rbind, tb)
tb$CI <- tidySEM::conf_int(lb = tb$ci.lb, ub = tb$ci.ub)
tb[c("ci.lb", "ci.ub")] <- NULL
names(tb) <- c("Parameter", "Estimate", "p", "Sample", "CI")
write.csv(tb, "tab_threelevel.csv", row.names = FALSE)
```
```{r, include = FALSE}
num_effect_sizes <- table(table(dat$id_sample))
```

## Descriptive statistics

The effect size estimates ranged from `r formatC(min(dat[["yi"]]), digits = 2, format = "f")` to `r formatC(max(dat[["yi"]]), digits = 2, format = "f")` ($M `r report(mean(dat[["yi"]]))`, SD `r report(sd(dat[["yi"]]))`$). 
**Five effect sizes exceeded 3 standard deviations from the mean effect size; consider removing these as outliers.**
Several studies reported multiple effect sizes (`r min(as.integer(names(num_effect_sizes))) ` - `r max(as.integer(names(num_effect_sizes)))`, with most reporting 1 effect size).

## Meta-analysis 

Meta-analysis was conducted in R [@rcore] using the R-packages `metafor` [@viechtbauerConductingMetaanalysesMetafor2010], and `pema` [@refpema].
To estimate overall effects, we used three-level meta-analysis to account for dependent effect sizes within studies [@vandennoortgateMetaanalysisMultipleOutcomes2015].
Let $y_{jk}$ denote the $j$ observed effect sizes $y$, originating from $k$ studies.
The multi-level model is then given by the following equations: 
<!--
\begin{center}
$\begin{equation}
\left.
\begin{aligned}
y_i &= \theta_i + \epsilon_i &\text{where } \epsilon_i &\sim N(0, \sigma^2_i)\\
\theta_i &= \mu + \zeta_i &\text{where } \zeta_i &\sim N(0, \tau^2)
\end{aligned}
\right\}
\end{equation}$
\end{center}
-->

$$
      \left.
      \begin{aligned}
        y_{jk} &= \beta_{jk} + \epsilon_{jk} &\text{where } \epsilon_{jk} &\sim N(0, \sigma^2_{\epsilon_{jk}})\\
        \beta_{jk} &= \theta_k + w_{jk} &\text{where } w_{jk} &\sim N(0, \sigma^2_{w})\\
        \theta_{k} &= \delta + b_{k} &\text{where } b_k &\sim N(0, \sigma^2_{b})
      \end{aligned}
      \right\}
$$

The first equation indicates that observed effect sizes are equal to the underlying population effect size, plus sampling error $\epsilon_{jk}$. The second equation indicates that population effect sizes within studies are a function of a study-specific true effect size, plus within-study residuals $w_{jk}$. The third equation indicates that the distribution of study-specific true effect sizes are distributed around an overall mean effect, with between-study residuals $b_k$.

Separate meta-analyses were conducted for each of the samples.
The overall pooled effect sizes were:

```{r, results = "asis"}
mlm <- readRDS("mlm.RData")
tb <- read.csv("tab_threelevel.csv", stringsAsFactors = FALSE)
# kbl(tb[, c("Parameter", "Estimate", "CI", "p", "Sample")], digits = 2) |>
#   kable_styling(bootstrap_options = c("striped", "hover"))
datatable(tb, rownames= FALSE, options = list(
              "pageLength" = nrow(tb))) |>
  formatRound(columns=c('Estimate', 'p'), digits=2)
```

The overall effect size estimate differed significantly from zero for `r paste0(tb[tb$Parameter == "Overall ES", ]$Sample[tb[tb$Parameter == "Overall ES", ]$p < .05], collapse = ", ")`.

The within-studies variance component $\sigma^2_w$ (between effect sizes) was significant for `r paste0(tb[tb$Parameter == "V within", ]$Sample[tb[tb$Parameter == "V within", ]$p < .05], collapse = ", ")`.

The between-studies variance $\sigma^2_b$ was significant for `r paste0(tb[tb$Parameter == "V between", ]$Sample[tb[tb$Parameter == "V between", ]$p < .05], collapse = ", ")`.

This indicates that there was substantial heterogeneity between average effect sizes, both within studies and across studies, in most of the samples.

## Forest plots

The forest plots for the aforementioned three-level meta-analyses are presented below.
Within each plot, studies are ranked by their sampling variance $vi$;
thus, the most precise estimates are at the bottom, near the overall effect.


```{r runplots, include=FALSE}
out = NULL
for (i in 1:length(samples)) {
  out = c(out, knit_expand('forest.rmd'))
}
```

`r paste(knit(text = out), collapse = '\n')`

## Moderator analyses

The effect of multiple moderators was investigated using meta-regression.
For two continuous variables, dose and HED, a quadratic term was computed to examine the non-linear (U-shaped) effect.
For categorical variables, dummies were encoded.
Note that the resulting moderator matrix had 25 columns.
As this exceeded in many cases the number of available effect sizes (per sample),
these models were not identified.
Addressing this problem requires performing variable selection.
Three steps were taken to do so.
First, variables and categories that did not occur within one subset of the data were omitted.
Secondly, some dummy variables were redundant because some studies had identical values on multiple dummy variables.
Only one of these redundant dummy variables was retained, and its name was updated to reflect all redundant dummies it represents.
For example, all of the studies in the category "Both" of the variable "sex" used the "public speaking test", and no other sex category used this test.
These two variables are therefore identical, and their effects cannot be distinguished.
Thus, the analysis shows their joint effect as an effect of `sexBoth.anxiety_testspeaking`.
Thirdly, despite these measures, many meta-regression models dropped all or some of the predictors,
or failed to converge entirely, suggesting the models were empirically non-identified.
Although these models are reported below,
we advise against their substantive interpretation.

The problems with meta-regression suggests that a technique is required that performs variable selection during analysis.
Such a technique was recently developed: Bayesian penalized meta-regression (BRMA), as implemented in the `pema` R-package (@refpema).
By imposing a regularizing (horseshoe) prior on the regression coefficients,
BRMA shrinks all coefficients towards zero, which aids empirical model identification.
Coefficients must overwhelm the prior in order to become significantly different from zero.
Thus, this method also performs variable selection: identifying which moderators are important in predicting the effect size.
The resulting regression coefficients are negatively biased by design, but the estimate of residual heterogeneity $\tau^2$ is unbiased.
Note that, as this is a Bayesian model, inference is based on credible intervals.
A credible interval is interpreted as follows: The population value falls within this interval with 95% probability (certainty).
This is different from the interpretation of frequentist confidence intervals, which are interpreted as follows: In the long run, 95% of confidence intervals contain the population value.

As the models contained several categorical variables but no meaningful reference category,
we estimated models _without_ an intercept, and instead included an equal number of dummies to the number of unique categories (ANOVA specification instead of regression specification).
To further aid interpretability, the dependent variable (effect size) was centered around the three-level multilevel meta-analysis estimated overall effect.
This means that the regression slope for each dummy variable reflects the deviation of that category from the overall effect size as estimated in the three-level multilevel meta-analysis.
If a dummy variable has a significant effect, that means that that group's mean differs significantly from the overall mean.
Note that in penalized regression, predictors are usually standardized.
However, the effect of standardized dummies cannot be meaningfully interpreted. 
Therefore, only continuous predictors were standardized in this analysis.
This may give dummy variables a slight advantage, leading them to become significant sooner than continuous ones.

```{r, eval = run_everything}
library(metacart)
source("../correct_metacart.R")
modres <- lapply(samples, function(p){
  df <- dat[dat$Sample == p, ]
  constcols <- sapply(df, function(i){length(unique(i)) < 2})
  constcolnames <- names(df)[constcols]
  theform <- stats::reformulate(mods[!mods %in% constcolnames])
  dfmod <- df[, mods[!mods %in% constcolnames]]
  dfmod$hed[is.na(dfmod$hed)] <- median(dfmod$hed, na.rm = TRUE)
  dfmod$hed2[is.na(dfmod$hed2)] <- dfmod$hed[is.na(dfmod$hed2)]^2
  modmat <- model.matrix(theform, dfmod)[,-1]
  constcols <- colSums(modmat) == 0 | colSums(modmat) == nrow(modmat)
  modmat <- modmat[, !constcols]
  modmatlist <- as.list(data.frame(modmat))
  dupcols <- duplicated(modmatlist)
  modmat <- modmat[, !dupcols]
  these_dups <- modmatlist[dupcols]
  modmatlist <- as.list(data.frame(modmat))
  for(i in 1:length(these_dups)){
    idnum <- which(duplicated(c(modmatlist, these_dups[i]), fromLast = T))
    colnames(modmat)[idnum] <- paste0(colnames(modmat)[idnum], ";", names(these_dups)[i])
  }
  yi_centered <- df$yi - mlm[[p]]$mod$b[1,1]
  res <- try(rma.mv(yi = yi_centered, V = df$vi, random = list(~ 1 | id_sample, ~ 1 | id_es), data = df, intercept = FALSE, mods = modmat))
  if(inherits(res, "try-error")){
    tabres <- NULL
  } else {
      vifs <- vif(res)
    confints <- confint(res)
  tabres <- data.frame(Parameter = c(rownames(res$b), "Tau2b", "Tau2w"),
                       Estimate = c(res$b, res$sigma2),
                       ci.lb = c(res$ci.lb, confints[[1]]$random[1,2], confints[[2]]$random[1,2]),
                       ci.ub = c(res$ci.ub, confints[[1]]$random[1,3], confints[[2]]$random[1,3]),
                       p = c(res$pval, NA, NA),
                       sig = c(c("", "*")[(res$pval < .05)+1], c("", "*")[(c(confints[[1]]$random[1,2], confints[[2]]$random[1,2])> 1e-4)+1]),
                       VIF = c(vifs$vif, NA, NA))
  tabres$CI <- conf_int(lb = tabres$ci.lb, ub = tabres$ci.ub)
  tabres[c("ci.lb", "ci.ub")] <- NULL
  tabres$Sample <- p
  tabres
  write.csv(tabres, paste0("rma_mods_", p, ".csv"))
  }
  
  moddat <- data.frame(df[c("yi", "vi")], modmat)
  cats <- sapply(moddat, function(x){all(x %in% c(0, 1))})
  std <- moddat[, !cats]
  std <- scale(std[, -c(1:2)])
  cats <- moddat[, cats]
  
  standardize <- list(
    center = c(attr(std,"scaled:center"), rep(0, ncol(cats))),
    scale = c(attr(std,"scaled:scale"), rep(1, ncol(cats)))
  )
  moddat <- cbind(yi = yi_centered, vi = df$vi, std, cats)
  
  moddat$study <- 1
  pma <- brma(yi ~-1+., study = "study", data = moddat, standardize = standardize)
  sumpma <- data.frame(summary(pma)$coefficients)
  sumpma <- cbind(rownames(sumpma), sumpma)
  names(sumpma)[1:3] <- c("Parameter", "Estimate", "se")
  sumpma <- sumpma[!sumpma$Parameter == "tau", ]
  rownames(sumpma) <- NULL
  sumpma$CI <- conf_int(lb = sumpma$X2.5., ub = sumpma$X97.5.)
  pstars <- c("*", "")[as.integer(apply(sumpma[, c("X2.5.", 
                                                   "X97.5.")], 1, function(x) {
                                                     sum(sign(x)) == 0
                                                   })) + 1]
  sumpma$p <- pstars
  sumpma[c("sd", grep("^X", names(sumpma), value = T))] <- NULL
  write.csv(sumpma, paste0("brma_mods_", p, ".csv"))
  moddatvi <- moddat$vi
  moddat <- moddat[, -which(colnames(moddat) == "vi")]
  set.seed(1)
  resmc <- suppressWarnings(REmrt(reformulate(names(moddat[2:(ncol(moddat)-1)]), response = "yi"), data = moddat, vi = moddatvi, c = 0))
  mc_tab <- data.frame(resmc$n, resmc$g, 
                                          resmc$se, resmc$pval, conf_int(lb = resmc$ci.lb, ub = resmc$ci.ub))
  
  names(mc_tab) <- c("Number", "Overall ES", "se", "pval", "CI")
  list(rma = tabres,
       brma = sumpma,
       mc = resmc,
       mc_tab = mc_tab)
})
names(modres) <- samples
saveRDS(modres, "modres.RData")
```

### Classic meta-regression

```{r}
modres <- readRDS("modres.RData")
```

Note that analyses containing VIF values greater than 5 should be regarded as problematic, due to multicolinearity.
This applies to nearly all models.

```{r run-numeric-md, include=FALSE}
out = NULL
for (i in 1:length(samples)) {
  out = c(out, knit_expand('tab_rma_template.rmd'))
}
```

`r paste(knit(text = out), collapse = '\n')`

### Bayesian regularized meta-regression:

```{r run-numeric-md2, include=FALSE}
out = NULL
for (i in 1:length(samples)) {
  out = c(out, knit_expand('tab_brma_template.rmd'))
}
```

`r paste(knit(text = out), collapse = '\n')`

# Conclusion

Based on three-level multilevel meta-analyses,
there is limited evidence that overall effects are non-zero in the population,
except for the samples "Acq retr to ctx" and "Ext retr to ctx".
All samples showed significant between-studies variance, except "Ext retr to cue".
Conversely, none of the samples showed significant within-studies variance, except "Acq retr to ctx".
There is thus substantial evidence that heterogeneity in effect sizes is mostly due to between-studies differences.

Classic meta-regression analyses were largely invalid for moderator analysis,
because of high multicolinearity among predictors.
BRMA analyses were used, which are robust to multicolinearity, and perform variable selection by shrinking regression coefficients towards zero.
These BRMA analyses revealed no consistent evidence of any significant moderator effect across samples.

